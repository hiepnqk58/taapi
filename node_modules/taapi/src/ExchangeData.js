const chalk = require("chalk");
const ccxt = require("ccxt");
const moment = require("moment");
const _ = require("lodash");

class ExchangeData
{
    constructor() {
        this.dataProviderName = "ccxt";
        this.dataProviderSecret = "";
        this.dataProviderEndpoint = null;
    }

    setDataProvider(name, secret, endpoint) {
        this.dataProviderName = name.toLowerCase();
        this.dataProviderSecret = secret;
        this.dataProviderEndpoint = endpoint;
    }

    setDataProviderTaapiCache(secret, endpoint) {
        this.setDataProvider("taapicache", secret, endpoint);
    }

    setDataProviderAlphaVantage(secret) {
        this.setDataProvider("alphavantage", secret);
    }

    setDataProviderFinnHub(secret) {
        this.setDataProvider("finnhub", secret);
    }

    /**
     * Fetch candles from an exchange. Check https://www.npmjs.com/package/ccxt for posible sources.
     * 
     * @param {*} source - This depends on the dataProvider set. For CCXT (or Crypto), this is the name of an exchange. If dataSource is 'alphavantage', this might be 'stock' Please read the Client documentation on https://taapi.io/documentation/integration/client/
     * @param {*} symbol 
     * @param {*} interval 
     * @param {*} backtrack 
     */
    async getCandles(source, symbol, interval, backtrack, candlesCount) {
        
        // Default backtracking
        if(backtrack) { 
            backtrack = parseInt(backtrack); 
        } else {
            backtrack = 0;
        }

        // Default candle count
        if(candlesCount) { 
            candlesCount = parseInt(candlesCount); 
        } else {
            candlesCount = 100;
        }
        
        let candles = [];

        switch(this.dataProviderName) {
            case "ccxt":

                const DataProviderCCXT = require("./dataProvider/CCXT");

                const dataProviderCCXT = new DataProviderCCXT();

                let since = null;

                if(candlesCount == -1) {
                    since = this.getSince(interval, 100);
                } else if(candlesCount > 0) {
                    since = this.getSince(interval, candlesCount);
                } 

                candles = await dataProviderCCXT.getCandles(source, symbol, interval, since, candlesCount);

                break;
            case "taapicache":

                const DataProviderTaapiCache = require("./dataProvider/TaapiCache");

                const dataProviderTaapiCache = new DataProviderTaapiCache(this.dataProviderSecret, this.dataProviderEndpoint);

                const source_provider = source.split(":")[0];
                const source_source = source.split(":")[1];

                if(!source_provider || !source_source) {
                    console.error("To use 'taapicache' as a data provider, the first parameter 'source' in method 'getCandles' needs to include both an original provider and a source. For example, 'ccxt:binance' or 'alphavantage:equity'");
                    return [];
                }

                candles = await dataProviderTaapiCache.getCandles(source_provider, source_source, symbol, interval, candlesCount);

                break;
            case "alphavantage":

                const DataProviderAlphaVantage = require("./dataProvider/AlphaVantage");

                const dataProviderAlphaVantage = new DataProviderAlphaVantage(this.dataProviderSecret);

                candles = await dataProviderAlphaVantage.getCandles(source, symbol, interval, candlesCount);

                break;
            case "finnhub":

                const DataProviderFinnHub = require("./dataProvider/FinnHub");

                const dataProviderFinnHub = new DataProviderFinnHub(this.dataProviderSecret);

                candles = await dataProviderFinnHub.getCandles(source, symbol, interval, candlesCount);

                break;
        }
        
        // Remove candles from the data set to match the backtrack
        let candlesBacktracked = [].concat(candles);
            
        for(let u = 0; u < backtrack; u++) {
            candlesBacktracked.pop();
        }

        return candlesBacktracked;
    }

    getSince(interval, candlesCount) {
        
        let since = moment().subtract(1 * candlesCount, "days").unix();
        
        switch(interval) {
            case "1m": since = moment().subtract(1 * candlesCount, "minutes").unix(); break;
            case "3m": since = moment().subtract(3 * candlesCount, "minutes").unix(); break;
            case "5m": since = moment().subtract(5 * candlesCount, "minutes").unix(); break;
            case "10m": since = moment().subtract(10 * candlesCount, "minutes").unix(); break;
            case "15m": since = moment().subtract(15 * candlesCount, "minutes").unix(); break;
            case "30m": since = moment().subtract(30 * candlesCount, "minutes").unix(); break;
            case "45m": since = moment().subtract(45 * candlesCount, "minutes").unix(); break;
            case "1h": since = moment().subtract(1 * candlesCount, "hours").unix(); break;
            case "2h": since = moment().subtract(2 * candlesCount, "hours").unix(); break;
            case "3h": since = moment().subtract(3 * candlesCount, "hours").unix(); break;
            case "4h": since = moment().subtract(4 * candlesCount, "hours").unix(); break;
            case "6h": since = moment().subtract(6 * candlesCount, "hours").unix(); break;
            case "8h": since = moment().subtract(8 * candlesCount, "hours").unix(); break;
            case "12h": since = moment().subtract(12 * candlesCount, "hours").unix(); break;
            case "1d": since = moment().subtract(1 * candlesCount, "days").unix(); break;
            case "2d": since = moment().subtract(2 * candlesCount, "days").unix(); break;
            case "3d": since = moment().subtract(3 * candlesCount, "days").unix(); break;
            case "4d": since = moment().subtract(4 * candlesCount, "days").unix(); break;
            case "1w": since = moment().subtract(1 * candlesCount, "weeks").unix(); break;
            default: since = moment().subtract(1 * candlesCount, "days").unix();
        }

        return since * 1000;
    }
}

// Export the ExchangeData wrapper
module.exports = ExchangeData;