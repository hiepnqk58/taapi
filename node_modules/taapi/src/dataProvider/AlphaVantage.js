const axios = require("axios");
const moment = require("moment");

class ExchangeDataAlphaVantage
{
    constructor(secret) {
        this.secret = secret;
    }

    getTimeframe(source, interval) {

        if(source === "equity") {
            switch(interval) {

                case "1m":
                    return { interval: "1min", functionInterval: "INTRADAY", responseDataKey: "Time Series (1min)" };
                case "5m":
                    return { interval: "5min", functionInterval: "INTRADAY", responseDataKey: "Time Series (5min)" };
                case "15m":
                    return { interval: "15min", functionInterval: "INTRADAY", responseDataKey: "Time Series (15min)" };
                case "30m":
                    return { interval: "30min", functionInterval: "INTRADAY", responseDataKey: "Time Series (30min)" };
                case "1h":
                    return { interval: "60min", functionInterval: "INTRADAY", responseDataKey: "Time Series (60min)" };
                case "1d":
                    return { functionInterval: "DAILY", responseDataKey: "Time Series (Daily)" };
                case "1w":
                    return { functionInterval: "WEEKLY", responseDataKey: "Weekly Time Series" };
                case "1M":
                    return { functionInterval: "MONTHLY", responseDataKey: "Monthly Time Series" };
                
            }

        } else if(source === "equity_adjusted") {

            switch(interval) {

                case "1d":
                    return { functionInterval: "DAILY", responseDataKey: "Time Series (Daily)" };
                case "1w":
                    return { functionInterval: "WEEKLY", responseDataKey: "Weekly Adjusted Time Series" };
                case "1M":
                    return { functionInterval: "MONTHLY", responseDataKey: "Monthly Adjusted Time Series" };
                default:
                    console.error("Error: AlphaVantage - does not support equity adjusted on intraday!");
                
            }

        } else if(source === "forex") {
            
            switch(interval) {

                case "1m":
                    return { interval: "1min", functionInterval: "INTRADAY", responseDataKey: "Time Series FX (1min)" };
                case "5m":
                    return { interval: "5min", functionInterval: "INTRADAY", responseDataKey: "Time Series FX (5min)" };
                case "15m":
                    return { interval: "15min", functionInterval: "INTRADAY", responseDataKey: "Time Series FX (15min)" };
                case "30m":
                    return { interval: "30min", functionInterval: "INTRADAY", responseDataKey: "Time Series FX (30min)" };
                case "1h":
                    return { interval: "60min", functionInterval: "INTRADAY", responseDataKey: "Time Series FX (60min)" };
                case "1d":
                    return { functionInterval: "DAILY", responseDataKey: "Time Series FX (Daily)" };
                case "1w":
                    return { functionInterval: "WEEKLY", responseDataKey: "Time Series FX (Weekly)" };
                case "1M":
                    return { functionInterval: "MONTHLY", responseDataKey: "Time Series FX (Monthly)" };
                
            }

        } else if(source === "crypto") {

            switch(interval) {
                case "1d":
                    return { functionInterval: "DAILY", responseDataKey: "Time Series (Digital Currency Daily)" };
                case "1w":
                    return { functionInterval: "WEEKLY", responseDataKey: "Time Series (Digital Currency Weekly)" };
                case "1M":
                    return { functionInterval: "MONTHLY", responseDataKey: "Time Series (Digital Currency Monthly)" };
                
            }

        }

        return null;
    }

    getSymbol(symbol) {

        let symbolDetails = {};

        if(symbol.includes("/")) {
            let symbolParts = symbol.split("/");

            symbolDetails.ticker = symbolParts[0].toUpperCase();
            symbolDetails.market = symbolParts[1].toUpperCase();
        } else {
            symbolDetails.ticker = symbol.toUpperCase();
        }
        
        return symbolDetails;
    }

    getFunctionName(source, interval) {

        let functionName = null;

        const timeframeDetails = this.getTimeframe(source, interval);

        // We need to have at least a function interval notation
        if(timeframeDetails && timeframeDetails.functionInterval) {
            switch(source) {
                case "equity":
                    functionName = `TIME_SERIES_${timeframeDetails.functionInterval}`;
                    break;
                case "equity_adjusted":
                    functionName = `TIME_SERIES_${timeframeDetails.functionInterval}_ADJUSTED`;
                    break;
                case "forex":
                    functionName = `FX_${timeframeDetails.functionInterval}`;
                    break;
                case "crypto":
                    functionName = `DIGITAL_CURRENCY_${timeframeDetails.functionInterval}`;
                    break;
            }
        }

        return functionName;
    }

    getOutputSize(candlesCount) {

        if(candlesCount == -1 || candlesCount > 100) {
            return "full";
        } else {
            return "compact";
        }
    }

    getEndpoint(source, symbol, interval, candlesCount) {

        if(!candlesCount) { candlesCount = 100; }

        let endpointUri = null;
        
        let functionName = this.getFunctionName(source, interval); //console.log("functionName: ", functionName);
        let timeframeDetails = this.getTimeframe(source, interval); //console.log("timeframeDetails: ", timeframeDetails);
        let symbolDetails = this.getSymbol(symbol); //console.log("symbolDetails: ", symbolDetails);
        let outputSize = this.getOutputSize(candlesCount); //console.log("outputSize: ", outputSize);

        if(this.secret) {
            if(functionName && symbolDetails.ticker) {

                switch(source) {
                    case "equity":

                        if(timeframeDetails.interval) {
                            endpointUri = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbolDetails.ticker}&interval=${timeframeDetails.interval}&outputsize=${outputSize}`;
                        } else {
                            endpointUri = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbolDetails.ticker}&outputsize=${outputSize}`;
                        }
                        
                        break;
                    case "equity_adjusted":
                        
                            if(timeframeDetails.interval) {
                                endpointUri = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbolDetails.ticker}&interval=${timeframeDetails.interval}&outputsize=${outputSize}`;
                            } else {
                                endpointUri = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbolDetails.ticker}&outputsize=${outputSize}`;
                            }

                        break;
                    case "forex":

                        if(symbolDetails.ticker && symbolDetails.market) {
                            if(timeframeDetails.interval) {
                                endpointUri = `https://www.alphavantage.co/query?function=${functionName}&from_symbol=${symbolDetails.ticker}&to_symbol=${symbolDetails.market}&interval=${timeframeDetails.interval}&outputsize=${outputSize}`;
                            } else {
                                endpointUri = `https://www.alphavantage.co/query?function=${functionName}&from_symbol=${symbolDetails.ticker}&to_symbol=${symbolDetails.market}&outputsize=${outputSize}`;
                            }
                        } else {
                            console.error("Error: AlphaVantage - Symbol does not contain a ticker and market part. Example: EUR/USD!");
                        }

                        break;
                    case "crypto":

                        if(symbolDetails.ticker && symbolDetails.market) {
                            endpointUri = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbolDetails.ticker}&market=${symbolDetails.market}`;
                        } else {
                            console.error("Error: AlphaVantage - Symbol does not contain a ticker and market key!");
                        }
                        break;
                }
                
            }

            // Append the secret if we have a valid endpoint
            if(endpointUri) {
                endpointUri += `&apikey=${this.secret}`;
            }

        } else {

            // No secret provided!
            console.error("Error: AlphaVantage - No Secret provided!");
        }
        
        return endpointUri;
    }

    getResponseDataKey(source, interval) {

        let timeframeDetails = this.getTimeframe(source, interval);

        return timeframeDetails.responseDataKey;
    }

    async getCandles(source, symbol, interval, candlesCount) {

        let endpointUri = await this.getEndpoint(source, symbol, interval, candlesCount);

        let responseDataKey = this.getResponseDataKey(source, interval);

        /* console.log("endpointUri: ", endpointUri);
        console.log("responseDataKey: ", responseDataKey); */
        let candles = [];

        if(endpointUri) {

            await axios.get(endpointUri, { })
                .then(function (response) {

                    let dataCandles = response.data[responseDataKey];

                    //console.log(dataCandles);

                    for(let humanTimestamp in dataCandles) {

                        let dataCandle = dataCandles[humanTimestamp];

                        let candle = {
                            /* source: source,
                            symbol: symbol,
                            interval: interval,
                            timestampHuman: moment(humanTimestamp, "YYYY-MM-DD").format("DD-MM-YYYY HH:mm:ss"), */
                            timestamp: moment(humanTimestamp, "YYYY-MM-DD H:m:s").unix() * 1000,
                            open: parseFloat(dataCandle["1. open"]),
                            high: parseFloat(dataCandle["2. high"]),
                            low: parseFloat(dataCandle["3. low"]),
                            close: parseFloat(dataCandle["4. close"]),
                            volume: parseFloat(dataCandle["5. volume"]),
                        };

                        candles.push(candle);
                    }

                    candles = candles.reverse();

                    if(candlesCount && candlesCount > 0) {
                        candles = candles.slice(candlesCount * -1);
                    }

                    //console.log(candles);
                })
                .catch(function (error) {
                    console.log(error);
                });

        }
        
        return candles;
    }
}

module.exports = ExchangeDataAlphaVantage;